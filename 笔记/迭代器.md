迭代器是一个可以记住遍历的位置的对象。迭代器对象从集合的第一个元素开始访问，直到所有的元素被访问完结束。迭代器只能往前不会后退。
迭代器有两个基本的方法：**iter()** 和 **next()**。
所以说，如果想要把一个类作为一个迭代器使用那就需要在类中实现两个方法 __iter__() 与 __next__()

为什么要用迭代器：
我个人理解：迭代器通俗来说就是保存了生成结果的代码，而没有生成结果【只有在调用的时候才生成】，节省了内存空间

```python
# coding=utf-8
from collections import Iterable


class Person():

    def __init__(self):
        self.names = list()

    def add_per(self, name):
        self.names.append(name)

if __name__ == '__main__':

    per = Person()
    per.add_per('老王')

    for item in per:
        print(item)
```

**当我们遍历per的时候显示`is not iterable`**
```sh
Traceback (most recent call last):
  File "C:\Users\Administrator\Desktop\Git\Archive\code\test.py", line 17, in <module>
    for item in per:
TypeError: 'Person' object is not iterable
[Finished in 0.2s]
```

**添加iter方法**
```python
# coding=utf-8
from collections import Iterable


class Person():

    def __init__(self):
        self.names = list()

    def add_per(self, name):
        self.names.append(name)

    def __iter__(self):
        return None

if __name__ == '__main__':

    per = Person()
    per.add_per('老王')

    for item in per:
        print(item)
```

**添加iter方法后，错误信息已经变成`iter() returned non-iterator of type 'NoneType'`**

```sh
Traceback (most recent call last):
  File "C:\Users\Administrator\Desktop\Git\Archive\code\test.py", line 21, in <module>
    for item in per:
TypeError: iter() returned non-iterator of type 'NoneType'
[Finished in 0.2s]
```

**完善代码**
```
StopIteration
StopIteration 异常用于标识迭代的完成，防止出现无限循环的情况，在 __next__()方法中我们可以设置在完成指定循环次数后触发StopIteration 异常来结束迭代。
```

```python
# coding=utf-8
from collections import Iterable


class Person(object):

    def __init__(self):
        self.count = 0
        self.names = list()

    def add_per(self, name):
        self.names.append(name)

    def __iter__(self):
        return self

    def __next__(self):
        if self.count < len(self.names):
            result = self.names[self.count]
            self.count += 1
            return result
        else:
            raise StopIteration

if __name__ == '__main__':

    per = Person()
    per.add_per('老A')
    per.add_per('老B')
    per.add_per('老C')

    for item in per:
        print(item)
```

```sh
老A
老B
老C
[Finished in 0.3s]
```

**也可以直接使用如下代码观测**
```python
    # print('是否可迭代对象：', isinstance(per, Iterable))
    # perper = iter(per)
    # print('是否迭代器：', isinstance(perper, Iterable))
```